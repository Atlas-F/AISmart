// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

/*********************
 * @file ui_events.c
 * @brief Squareline导出ui_event事件回调函数与自定义函数文件
 * @author LFG (lfg@.com)
 * @version 1.0
 * @date 2025-06-13
 * 
 * @copyright Copyright (c) 2025  LFG
 * 
 *************************************************/
/* [USER CODE BEGIN ui_event] */
 
#include "ui.h"
#include <time.h>
#include <stdlib.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h> 

#include <stdio.h>
#include <sys/ioctl.h> 

#include "ui_events.h"
#include <stdio.h>

#include <errno.h>

// 下面语句与上面两条预处理在从欧冠SquareLine中将ui导出后要添加到ui.c中
# if 0
extern  lv_timer_t *emoji_timer;

_ui_label_set_property(ui_AILabel, _UI_LABEL_PROPERTY_TEXT, "设置AIlabel");

#endif






/*********************
 * @brief 初始化全局emoji定时器和上一个显示索引
 *************************************************/
lv_timer_t *emoji_timer = NULL;
static uint8_t last_idx = 0;  // 初始化为无效索引

// 时间日期定时器 
lv_timer_t * timeDateTimer = NULL;

FILE * ftex = NULL;

/*********************
 * @brief 定时器回调函数
 * @param  timer 定时器
 * @param idx 显示表情索引
 * @param last_idx 上一个显示索引
 * @details 获取定时器，获取父控件，获取父控件下子控件的个数
 *          生成一个范围在子控件个数内的随机索引，作为显示表情的索引，显示当前索引表情并隐藏上一个
 *          索引表情
 *************************************************/
static void emoji_change_timer_cb(lv_timer_t *timer)
{
    lv_obj_t *screen = (lv_obj_t *)timer->user_data;
    lv_obj_t * container = lv_obj_get_child(screen, 1);
    uint16_t child_cnt = lv_obj_get_child_cnt(container);
    
    if(child_cnt == 0) return;
    // 生成一个与上次不同的随机索引
    uint16_t idx;
    do {
        idx = rand() % child_cnt;
		printf("生成随机索引！：%d\n", idx);
    } while(idx == last_idx && child_cnt > 1);

    // 隐藏表情
    printf("last_idx 索引为 %d\n", last_idx);
    lv_obj_add_flag(lv_obj_get_child(container, last_idx), LV_OBJ_FLAG_HIDDEN);

    // 显示选中的表情
    lv_obj_t *curImage = lv_obj_get_child(container, idx);
    lv_obj_clear_flag(curImage, LV_OBJ_FLAG_HIDDEN);
    printf("显示表情！%d\n", idx);
    // 随机设置下一次切换的时间间隔（1-3秒）
    lv_timer_set_period(timer, 1000 + rand() % 2000);

    last_idx = idx;
}


/*********************
 * @brief 初始化随机数生成器，并创建定时器
 * @param  e 
 * @details 创建定时器，每一秒执行一次回调函数
 *************************************************/
void InitEmojiAutoChange(lv_event_t *e)
{
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t * ta = lv_event_get_target(e);
    if(code != LV_EVENT_SCREEN_LOADED) return;  // 确保只在屏幕加载时执行一次
    if( code == LV_EVENT_SCREEN_LOADED )
    {
        lv_obj_t *screen = lv_event_get_target(e);
        srand(time(NULL));
        emoji_timer = lv_timer_create(emoji_change_timer_cb, 1000, screen);
        printf("创建定时器！\n"); 
    }
}


void TimeDateTimercb(lv_timer_t *timer)
{
    GetOutNowTime();
    GetOutNowDate();
}

void InitSowTimeDate(lv_event_t *e)
{
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t * ta = lv_event_get_target(e);
    if(code != LV_EVENT_SCREEN_LOADED) return;  // 确保只在屏幕加载时执行一次
    if( code == LV_EVENT_SCREEN_LOADED )
    {
        timeDateTimer = lv_timer_create(TimeDateTimercb, 1000, NULL);
    }
}



/*********************
 * @brief 初始化表情切换，并准备定时器
 * @param  e 
 *************************************************/
void InitScreenAutoChangeEmoji(lv_event_t * e)
{
	// Your code here
    lv_event_code_t code = lv_event_get_code(e);
    if( code == LV_EVENT_SCREEN_LOADED  )
    {
        printf("进行定时器！\n");
        // InitEmojiAutoChange(e);
    }
}


void UnloadScreenAutoEmojiChange(lv_event_t * e)
{
	// Your code here
}



void InitUnLoad(lv_event_t * e)
{
	// Your code here
}



void GetOutNowTime()
{
        time_t now;
        struct tm *local_time;
        time(&now);
        local_time = localtime(&now);
  
        int month = local_time->tm_mon + 1;
          // 月份从0开始，所以加1    
        int day = local_time->tm_mday;
        int hour = local_time->tm_hour;
        int min = local_time->tm_min;
        int sec = local_time->tm_sec;
        printf("今天是 %d月%d日%d时%d分%d秒\n", month, day, hour, min, sec);
        
        lv_label_set_text_fmt(ui_time2, "%d:%d:%d", hour, min, sec);
        
}

void GetOutNowDate()
{
        time_t now;
        struct tm *local_time;
        time(&now);
        local_time = localtime(&now);
  
        int year = local_time->tm_year;
        int month = local_time->tm_mon + 1;
          // 月份从0开始，所以加1    
        int day = local_time->tm_mday;
        int hour = local_time->tm_hour;
        int min = local_time->tm_min;
        int sec = local_time->tm_sec;
        printf("今天是 %d月%d日%d时%d分%d秒\n", month, day, hour, min, sec);
        
        lv_label_set_text_fmt(ui_date2, "%d-%d", month, day);
        
}

/*********************
 * @brief 点击用户label区域更新文本
 * @param  e 
 * @details 目前数据量小，使用系统IO
 *************************************************/
void ChangeHumanLabelTextClick(lv_event_t * e)
{

    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);

    const char* base_dir = __FILE__;
    printf("%s\n", base_dir);
    ///mnt/hgfs/ub2004sf/AISmart/UBSDL-lvgl/AiSmart/
    if(ftex == NULL) 
    {
        printf("文件打开失败！\n");
        // printf("完整路径: %s\n", filepath);
        printf("错误信息: %s (errno: %d)\n", strerror(errno), errno);
        perror("fopen");        
        return;
    }
    printf("文件打开成功！\n");
    /*********************
     * @details 使用系统IO进入文件并读取，然后对文件内容进行判断。
     * 按行读取，
     * 将行首冒号清的字符进行判断，如果行首的前两个字符是AI则设置到AILabel，如果是人类，则设置到humanLabel。
     * 使用fgets按行读取，匹配后移动指针，然后自复制
     * 将每一段内容都放在一行中，以句号或者问号结尾。
     * 将文件流设置为全局变量
     * 对于长内容的滚动显示一遍后定格，或者显示滑动条
     *********************/
    char  lineBuffer[1024] = {0};

    char  AIText[1024] = {0};
    char  humanText[1024] = {0};
    char  TempBuf[32] = {0};

    int offset;

    while( fgets(lineBuffer, sizeof(lineBuffer), ftex) )
    {
        sscanf(lineBuffer, "%[^:]%n", TempBuf, &offset);
        printf("%s\n", TempBuf);
        if( strcmp("AI", TempBuf) == 0 )
        {
            printf("匹配AIText\n");
            strcpy(lineBuffer, lineBuffer+offset);
            printf("%s\n", lineBuffer);
            lv_label_set_text(ui_AILabel, lineBuffer);
            break;
        }
        if( strcmp("human", TempBuf) == 0)
        {
            printf("%s\n", lineBuffer);
            printf("匹配HumanText\n");
            strcpy(lineBuffer, lineBuffer+offset);
            lv_label_set_text(ui_humanLabel, lineBuffer);
            break;
        }
        if( strcmp("attention", TempBuf) == 0)
        {
            printf("退出Text\n");
            fclose(ftex);
            break;
        }

    }
}


#if 0
void ui_event_Screen1(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    ftex = fopen("/mnt/hgfs/ub2004sf/AISmart/UBSDL-lvgl/AiSmart/SimuTalk-copy.txt", "r");

    InitEmojiAutoChange(e);
    InitSowTimeDate(e);
    
    if(event_code == LV_EVENT_SCREEN_LOADED) {
        printf("进入定时器\n");
        InitScreenAutoChangeEmoji(e);
    }
    if(event_code == LV_EVENT_GESTURE &&  lv_indev_get_gesture_dir(lv_indev_get_act()) == LV_DIR_LEFT) {
        printf("暂停定时器\n");
        lv_timer_pause(emoji_timer);
        lv_indev_wait_release(lv_indev_get_act());
        _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_MOVE_LEFT, 500, 0, &ui_Screen2_screen_init);
    }
    if(event_code == LV_EVENT_SCREEN_UNLOADED) {
        printf("删除定时器\n");
        lv_timer_del(emoji_timer);
        InitUnLoad(e);
    }
    if(event_code == LV_EVENT_CLICKED) {
        printf("暂停定时器\n");
        lv_timer_pause(emoji_timer);
        _ui_flag_modify(ui_time, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
        _ui_flag_modify(ui_date, LV_OBJ_FLAG_HIDDEN, _UI_MODIFY_FLAG_REMOVE);
    }
    if(event_code == LV_EVENT_GESTURE &&  lv_indev_get_gesture_dir(lv_indev_get_act()) == LV_DIR_BOTTOM) {
        printf("暂停定时器\n");
        lv_timer_pause(emoji_timer);
        lv_indev_wait_release(lv_indev_get_act());
        _ui_screen_change(&ui_Screen4, LV_SCR_LOAD_ANIM_MOVE_BOTTOM, 500, 0, &ui_Screen4_screen_init);
    }
}

#endif 

/* [USER CODE END ui_event] */

void SetLabel(lv_event_t * e)
{
	// Your code here
    ChangeHumanLabelTextClick(e);
    // lv_event_code_t code = lv_event_get_code(e);
    // lv_obj_t * ta = lv_event_get_target(e);
    // printf("准备打开文件！\n"); 
    // ftex = fopen("SimuTalk-copy.txt","r");
    // // printf("文件打开成功！\n");
    // if(ftex == NULL) {
    //     printf("文件打开失败！\n");
    //     return;
    // }
    

    // char  lineBuffer[1024] = {0};

    // char  AIText[1024] = {0};
    // char  humanText[1024] = {0};
    // char  TempBuf[32] = {0};

    // int offset;
    // int c;
    // c = fgetc(ftex);
    // printf("%c", c);

//     while(1)
//    {
//       c = fgetc(ftex);
//       if( feof(ftex) )
//       { 
//           break ;
//       }
//       printf("%c", c);
//    }

    // while( fgets(lineBuffer, sizeof(lineBuffer), ftex) )
    // {
    //     sscanf(lineBuffer, "%[^：]%n", TempBuf, &offset);
    //     if( strcmp("AI", TempBuf) )
    //     {
    //         printf("匹配AIText\n");
    //         strcpy(lineBuffer, lineBuffer+offset);
    //         lv_label_set_text(ui_AILabel, lineBuffer);
    //         break;
    //     }
    //     if( strcmp("人类", TempBuf) )
    //     {
    //         printf("匹配HumanText\n");
    //         strcpy(lineBuffer, lineBuffer+offset);
    //         lv_label_set_text(ui_humanLabel, lineBuffer);
    //         break;
    //     }
    //     if( strcmp("注", TempBuf) )
    //     {
    //         printf("退出Text\n");
    //         fclose(ftex);
    //         break;
    //     }
    // }
}
